<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NodeC: Streams</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-blue-55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NodeC
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__streams.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Streams</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaf8015d9228ada99910bc414d748536e8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streams.html#gaf8015d9228ada99910bc414d748536e8">using_stream</a>(s)&#160;&#160;&#160;defer_exit(<a class="el" href="group__streams.html#ga530b49b85b811a2377209a55b2e670cb">async_shutdown</a>(s),&amp;<a class="el" href="group__streams.html#ga29902a3b1e06b6d1b87e11b12bfbb11a">nodec_stream_freev</a>,lh_value_ptr(s))</td></tr>
<tr class="memdesc:gaf8015d9228ada99910bc414d748536e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a stream in a scope, freeing the stream when exiting.  <a href="#gaf8015d9228ada99910bc414d748536e8">More...</a><br /></td></tr>
<tr class="separator:gaf8015d9228ada99910bc414d748536e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3371300a9eea0177e792b08bb5b3bf3d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streams.html#ga3371300a9eea0177e792b08bb5b3bf3d">using_bstream</a>(s)&#160;&#160;&#160;<a class="el" href="group__streams.html#gaf8015d9228ada99910bc414d748536e8">using_stream</a>(<a class="el" href="group__streams.html#ga5086fb89c05a1dc0ecf923af3e953403">as_stream</a>(s))</td></tr>
<tr class="memdesc:ga3371300a9eea0177e792b08bb5b3bf3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a buffered stream in a scope, freeing the stream when exiting.  <a href="#ga3371300a9eea0177e792b08bb5b3bf3d">More...</a><br /></td></tr>
<tr class="separator:ga3371300a9eea0177e792b08bb5b3bf3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaee920c8bd173ce7bf3b57f42cbcf3f5f"><td class="memItemLeft" align="right" valign="top"><a id="gaee920c8bd173ce7bf3b57f42cbcf3f5f"></a>
typedef struct _nodec_stream_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streams.html#gaee920c8bd173ce7bf3b57f42cbcf3f5f">nodec_stream_t</a></td></tr>
<tr class="memdesc:gaee920c8bd173ce7bf3b57f42cbcf3f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic unbuffered streams. <br /></td></tr>
<tr class="separator:gaee920c8bd173ce7bf3b57f42cbcf3f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaf4d5e2ac9a12cc14da8fa006d85916"><td class="memItemLeft" align="right" valign="top">typedef struct _nodec_bstream_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streams.html#gadaf4d5e2ac9a12cc14da8fa006d85916">nodec_bstream_t</a></td></tr>
<tr class="memdesc:gadaf4d5e2ac9a12cc14da8fa006d85916"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of buffered streams.  <a href="#gadaf4d5e2ac9a12cc14da8fa006d85916">More...</a><br /></td></tr>
<tr class="separator:gadaf4d5e2ac9a12cc14da8fa006d85916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1b461b8603be0c65dbf1e6037b01668"><td class="memItemLeft" align="right" valign="top">typedef struct _uv_stream_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streams.html#gaa1b461b8603be0c65dbf1e6037b01668">uv_stream_t</a></td></tr>
<tr class="memdesc:gaa1b461b8603be0c65dbf1e6037b01668"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code>libuv</code> stream.  <a href="#gaa1b461b8603be0c65dbf1e6037b01668">More...</a><br /></td></tr>
<tr class="separator:gaa1b461b8603be0c65dbf1e6037b01668"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7a87a30d292c709502440b0d95b9cb0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streams.html#ga7a87a30d292c709502440b0d95b9cb0b">nodec_stream_free</a> (<a class="el" href="group__streams.html#gaee920c8bd173ce7bf3b57f42cbcf3f5f">nodec_stream_t</a> *stream)</td></tr>
<tr class="memdesc:ga7a87a30d292c709502440b0d95b9cb0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a basic stream.  <a href="#ga7a87a30d292c709502440b0d95b9cb0b">More...</a><br /></td></tr>
<tr class="separator:ga7a87a30d292c709502440b0d95b9cb0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29902a3b1e06b6d1b87e11b12bfbb11a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streams.html#ga29902a3b1e06b6d1b87e11b12bfbb11a">nodec_stream_freev</a> (lh_value streamv)</td></tr>
<tr class="memdesc:ga29902a3b1e06b6d1b87e11b12bfbb11a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a basic stream as an <code>lh_value</code>.  <a href="#ga29902a3b1e06b6d1b87e11b12bfbb11a">More...</a><br /></td></tr>
<tr class="separator:ga29902a3b1e06b6d1b87e11b12bfbb11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga530b49b85b811a2377209a55b2e670cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streams.html#ga530b49b85b811a2377209a55b2e670cb">async_shutdown</a> (<a class="el" href="group__streams.html#gaee920c8bd173ce7bf3b57f42cbcf3f5f">nodec_stream_t</a> *stream)</td></tr>
<tr class="memdesc:ga530b49b85b811a2377209a55b2e670cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shutdown a stream.  <a href="#ga530b49b85b811a2377209a55b2e670cb">More...</a><br /></td></tr>
<tr class="separator:ga530b49b85b811a2377209a55b2e670cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga756ccec235ed35716f4c725a948a7943"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__buffers.html#structuv__buf__t">uv_buf_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streams.html#ga756ccec235ed35716f4c725a948a7943">async_read_bufx</a> (<a class="el" href="group__streams.html#gaee920c8bd173ce7bf3b57f42cbcf3f5f">nodec_stream_t</a> *stream, bool *buf_owned)</td></tr>
<tr class="memdesc:ga756ccec235ed35716f4c725a948a7943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously read a buffer from a stream.  <a href="#ga756ccec235ed35716f4c725a948a7943">More...</a><br /></td></tr>
<tr class="separator:ga756ccec235ed35716f4c725a948a7943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c8beb53a775b37e696fdf5e8e31d6d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__buffers.html#structuv__buf__t">uv_buf_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streams.html#ga3c8beb53a775b37e696fdf5e8e31d6d6">async_read_buf</a> (<a class="el" href="group__streams.html#gaee920c8bd173ce7bf3b57f42cbcf3f5f">nodec_stream_t</a> *stream)</td></tr>
<tr class="memdesc:ga3c8beb53a775b37e696fdf5e8e31d6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously read a buffer from a stream.  <a href="#ga3c8beb53a775b37e696fdf5e8e31d6d6">More...</a><br /></td></tr>
<tr class="separator:ga3c8beb53a775b37e696fdf5e8e31d6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1285146007f649dc4afab2d4c97ed0a8"><td class="memItemLeft" align="right" valign="top"><a id="ga1285146007f649dc4afab2d4c97ed0a8"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streams.html#ga1285146007f649dc4afab2d4c97ed0a8">async_read</a> (<a class="el" href="group__streams.html#gaee920c8bd173ce7bf3b57f42cbcf3f5f">nodec_stream_t</a> *stream)</td></tr>
<tr class="memdesc:ga1285146007f649dc4afab2d4c97ed0a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously read a string from a stream. <br /></td></tr>
<tr class="separator:ga1285146007f649dc4afab2d4c97ed0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga254f878556059c35448ad927ab982f36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streams.html#ga254f878556059c35448ad927ab982f36">async_write_bufs</a> (<a class="el" href="group__streams.html#gaee920c8bd173ce7bf3b57f42cbcf3f5f">nodec_stream_t</a> *stream, <a class="el" href="group__buffers.html#structuv__buf__t">uv_buf_t</a> bufs[], size_t count)</td></tr>
<tr class="memdesc:ga254f878556059c35448ad927ab982f36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an array of buffers to a stream.  <a href="#ga254f878556059c35448ad927ab982f36">More...</a><br /></td></tr>
<tr class="separator:ga254f878556059c35448ad927ab982f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga025bb7d59c9dae3b4899e0874d08dc68"><td class="memItemLeft" align="right" valign="top"><a id="ga025bb7d59c9dae3b4899e0874d08dc68"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streams.html#ga025bb7d59c9dae3b4899e0874d08dc68">async_write_buf</a> (<a class="el" href="group__streams.html#gaee920c8bd173ce7bf3b57f42cbcf3f5f">nodec_stream_t</a> *stream, <a class="el" href="group__buffers.html#structuv__buf__t">uv_buf_t</a> buf)</td></tr>
<tr class="memdesc:ga025bb7d59c9dae3b4899e0874d08dc68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a buffer to a stream. <br /></td></tr>
<tr class="separator:ga025bb7d59c9dae3b4899e0874d08dc68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga333329e70821cc682fdeaa333f210260"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streams.html#ga333329e70821cc682fdeaa333f210260">async_write</a> (<a class="el" href="group__streams.html#gaee920c8bd173ce7bf3b57f42cbcf3f5f">nodec_stream_t</a> *stream, const char *s)</td></tr>
<tr class="memdesc:ga333329e70821cc682fdeaa333f210260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a string to a stream.  <a href="#ga333329e70821cc682fdeaa333f210260">More...</a><br /></td></tr>
<tr class="separator:ga333329e70821cc682fdeaa333f210260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5086fb89c05a1dc0ecf923af3e953403"><td class="memItemLeft" align="right" valign="top"><a id="ga5086fb89c05a1dc0ecf923af3e953403"></a>
<a class="el" href="group__streams.html#gaee920c8bd173ce7bf3b57f42cbcf3f5f">nodec_stream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streams.html#ga5086fb89c05a1dc0ecf923af3e953403">as_stream</a> (<a class="el" href="group__streams.html#gadaf4d5e2ac9a12cc14da8fa006d85916">nodec_bstream_t</a> *stream)</td></tr>
<tr class="memdesc:ga5086fb89c05a1dc0ecf923af3e953403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely cast a buffered stream to a basic stream. <br /></td></tr>
<tr class="separator:ga5086fb89c05a1dc0ecf923af3e953403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga353b56dd825e99a056c7cd6ebfd1635a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__buffers.html#structuv__buf__t">uv_buf_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streams.html#ga353b56dd825e99a056c7cd6ebfd1635a">async_read_buf_all</a> (<a class="el" href="group__streams.html#gadaf4d5e2ac9a12cc14da8fa006d85916">nodec_bstream_t</a> *bstream, size_t read_max)</td></tr>
<tr class="memdesc:ga353b56dd825e99a056c7cd6ebfd1635a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the entire stream as a single buffer.  <a href="#ga353b56dd825e99a056c7cd6ebfd1635a">More...</a><br /></td></tr>
<tr class="separator:ga353b56dd825e99a056c7cd6ebfd1635a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8406e8a53fce782cb90557358c6290c3"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streams.html#ga8406e8a53fce782cb90557358c6290c3">async_read_all</a> (<a class="el" href="group__streams.html#gadaf4d5e2ac9a12cc14da8fa006d85916">nodec_bstream_t</a> *bstream, size_t read_max)</td></tr>
<tr class="memdesc:ga8406e8a53fce782cb90557358c6290c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the entire stream as a string.  <a href="#ga8406e8a53fce782cb90557358c6290c3">More...</a><br /></td></tr>
<tr class="separator:ga8406e8a53fce782cb90557358c6290c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0d28422e33ff8ba269b4982ec7160aa"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streams.html#gae0d28422e33ff8ba269b4982ec7160aa">async_read_into</a> (<a class="el" href="group__streams.html#gadaf4d5e2ac9a12cc14da8fa006d85916">nodec_bstream_t</a> *bstream, <a class="el" href="group__buffers.html#structuv__buf__t">uv_buf_t</a> buf)</td></tr>
<tr class="memdesc:gae0d28422e33ff8ba269b4982ec7160aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a stream into a pre-allocated buffer.  <a href="#gae0d28422e33ff8ba269b4982ec7160aa">More...</a><br /></td></tr>
<tr class="separator:gae0d28422e33ff8ba269b4982ec7160aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdf6ced2f262d5a4285465e347af1d79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__buffers.html#structuv__buf__t">uv_buf_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streams.html#gabdf6ced2f262d5a4285465e347af1d79">async_read_buf_including</a> (<a class="el" href="group__streams.html#gadaf4d5e2ac9a12cc14da8fa006d85916">nodec_bstream_t</a> *bstream, size_t *toread, const void *pat, size_t pat_len, size_t read_max)</td></tr>
<tr class="memdesc:gabdf6ced2f262d5a4285465e347af1d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a stream until some pattern is encountered.  <a href="#gabdf6ced2f262d5a4285465e347af1d79">More...</a><br /></td></tr>
<tr class="separator:gabdf6ced2f262d5a4285465e347af1d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga944deab13d009fe3b6b94a8c7c4943b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__buffers.html#structuv__buf__t">uv_buf_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streams.html#ga944deab13d009fe3b6b94a8c7c4943b9">async_read_buf_upto</a> (<a class="el" href="group__streams.html#gadaf4d5e2ac9a12cc14da8fa006d85916">nodec_bstream_t</a> *bstream, const void *pat, size_t pat_len, size_t read_max)</td></tr>
<tr class="memdesc:ga944deab13d009fe3b6b94a8c7c4943b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a stream until some pattern is encountered.  <a href="#ga944deab13d009fe3b6b94a8c7c4943b9">More...</a><br /></td></tr>
<tr class="separator:ga944deab13d009fe3b6b94a8c7c4943b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7691ad253e2f25057450847e697fc210"><td class="memItemLeft" align="right" valign="top"><a id="ga7691ad253e2f25057450847e697fc210"></a>
<a class="el" href="group__buffers.html#structuv__buf__t">uv_buf_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streams.html#ga7691ad253e2f25057450847e697fc210">async_read_buf_line</a> (<a class="el" href="group__streams.html#gadaf4d5e2ac9a12cc14da8fa006d85916">nodec_bstream_t</a> *bstream)</td></tr>
<tr class="memdesc:ga7691ad253e2f25057450847e697fc210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the first line of a buffered stream. <br /></td></tr>
<tr class="separator:ga7691ad253e2f25057450847e697fc210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1b8928176f1a3e88f2683c66324bab0"><td class="memItemLeft" align="right" valign="top"><a id="gaf1b8928176f1a3e88f2683c66324bab0"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streams.html#gaf1b8928176f1a3e88f2683c66324bab0">async_read_line</a> (<a class="el" href="group__streams.html#gadaf4d5e2ac9a12cc14da8fa006d85916">nodec_bstream_t</a> *bstream)</td></tr>
<tr class="memdesc:gaf1b8928176f1a3e88f2683c66324bab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the first line as a string from a buffered stream. <br /></td></tr>
<tr class="separator:gaf1b8928176f1a3e88f2683c66324bab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2323dea0f12493ae97032fe7e6dcd55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streams.html#gaa2323dea0f12493ae97032fe7e6dcd55">nodec_pushback_buf</a> (<a class="el" href="group__streams.html#gadaf4d5e2ac9a12cc14da8fa006d85916">nodec_bstream_t</a> *bstream, <a class="el" href="group__buffers.html#structuv__buf__t">uv_buf_t</a> buf)</td></tr>
<tr class="memdesc:gaa2323dea0f12493ae97032fe7e6dcd55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push back a buffer onto a read stream.  <a href="#gaa2323dea0f12493ae97032fe7e6dcd55">More...</a><br /></td></tr>
<tr class="separator:gaa2323dea0f12493ae97032fe7e6dcd55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1bf780a5ccea514dc1592f8a0eccb58"><td class="memItemLeft" align="right" valign="top"><a id="gaa1bf780a5ccea514dc1592f8a0eccb58"></a>
<a class="el" href="group__streams.html#gadaf4d5e2ac9a12cc14da8fa006d85916">nodec_bstream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streams.html#gaa1bf780a5ccea514dc1592f8a0eccb58">nodec_bstream_alloc_on</a> (<a class="el" href="group__streams.html#gaee920c8bd173ce7bf3b57f42cbcf3f5f">nodec_stream_t</a> *source)</td></tr>
<tr class="memdesc:gaa1bf780a5ccea514dc1592f8a0eccb58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a buffered stream from a plain stream. <br /></td></tr>
<tr class="separator:gaa1bf780a5ccea514dc1592f8a0eccb58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3402e9960bf043d2d361225e18483645"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__streams.html#gadaf4d5e2ac9a12cc14da8fa006d85916">nodec_bstream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streams.html#ga3402e9960bf043d2d361225e18483645">nodec_bstream_alloc</a> (<a class="el" href="group__streams.html#gaa1b461b8603be0c65dbf1e6037b01668">uv_stream_t</a> *stream)</td></tr>
<tr class="memdesc:ga3402e9960bf043d2d361225e18483645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low level: Create a buffered stream from an internal <code>uv_stream_t</code>.  <a href="#ga3402e9960bf043d2d361225e18483645">More...</a><br /></td></tr>
<tr class="separator:ga3402e9960bf043d2d361225e18483645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac952f2f3a280250a382a36419f7b16da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__streams.html#gadaf4d5e2ac9a12cc14da8fa006d85916">nodec_bstream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streams.html#gac952f2f3a280250a382a36419f7b16da">nodec_bstream_alloc_read</a> (<a class="el" href="group__streams.html#gaa1b461b8603be0c65dbf1e6037b01668">uv_stream_t</a> *stream)</td></tr>
<tr class="memdesc:gac952f2f3a280250a382a36419f7b16da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low level: Create a buffered stream from an internal <code>uv_stream_t</code> for reading.  <a href="#gac952f2f3a280250a382a36419f7b16da">More...</a><br /></td></tr>
<tr class="separator:gac952f2f3a280250a382a36419f7b16da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46bab5d4f8f6d45e6eb3587b796683a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__streams.html#gadaf4d5e2ac9a12cc14da8fa006d85916">nodec_bstream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streams.html#ga46bab5d4f8f6d45e6eb3587b796683a2">nodec_bstream_alloc_read_ex</a> (<a class="el" href="group__streams.html#gaa1b461b8603be0c65dbf1e6037b01668">uv_stream_t</a> *stream, size_t alloc_init, size_t alloc_max)</td></tr>
<tr class="memdesc:ga46bab5d4f8f6d45e6eb3587b796683a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low level: Create a buffered stream from an internal <code>uv_stream_t</code> for reading.  <a href="#ga46bab5d4f8f6d45e6eb3587b796683a2">More...</a><br /></td></tr>
<tr class="separator:ga46bab5d4f8f6d45e6eb3587b796683a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a923b29a649bffb076c7d7c10d14459"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__streams.html#gadaf4d5e2ac9a12cc14da8fa006d85916">nodec_bstream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streams.html#ga8a923b29a649bffb076c7d7c10d14459">nodec_zstream_alloc</a> (<a class="el" href="group__streams.html#gaee920c8bd173ce7bf3b57f42cbcf3f5f">nodec_stream_t</a> *stream)</td></tr>
<tr class="memdesc:ga8a923b29a649bffb076c7d7c10d14459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a stream over another stream that is gzip'd.  <a href="#ga8a923b29a649bffb076c7d7c10d14459">More...</a><br /></td></tr>
<tr class="separator:ga8a923b29a649bffb076c7d7c10d14459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e497767efc4c4d27982e5c9771dfb2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__streams.html#gadaf4d5e2ac9a12cc14da8fa006d85916">nodec_bstream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__streams.html#ga2e497767efc4c4d27982e5c9771dfb2c">nodec_zstream_alloc_ex</a> (<a class="el" href="group__streams.html#gaee920c8bd173ce7bf3b57f42cbcf3f5f">nodec_stream_t</a> *stream, int compress_level, bool gzip)</td></tr>
<tr class="memdesc:ga2e497767efc4c4d27982e5c9771dfb2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a stream over another stream that is gzip'd.  <a href="#ga2e497767efc4c4d27982e5c9771dfb2c">More...</a><br /></td></tr>
<tr class="separator:ga2e497767efc4c4d27982e5c9771dfb2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga3371300a9eea0177e792b08bb5b3bf3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3371300a9eea0177e792b08bb5b3bf3d">&#9670;&nbsp;</a></span>using_bstream</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define using_bstream</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__streams.html#gaf8015d9228ada99910bc414d748536e8">using_stream</a>(<a class="el" href="group__streams.html#ga5086fb89c05a1dc0ecf923af3e953403">as_stream</a>(s))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use a buffered stream in a scope, freeing the stream when exiting. </p>
<p>This safely uses the stream in a scope and frees the stream afterwards (even if an exception is thrown). Uses async_shutdown(stream) too if no exception was thrown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the <a class="el" href="group__streams.html#gadaf4d5e2ac9a12cc14da8fa006d85916" title="The type of buffered streams. ">nodec_bstream_t</a> to free after use.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example</b> </p><div class="fragment"><div class="line"><a class="code" href="group__streams.html#gadaf4d5e2ac9a12cc14da8fa006d85916">nodec_bstream_t</a> s = nodec_tcp_connect(<span class="stringliteral">&quot;http://www.google.com&quot;</span>);</div><div class="line">{<a class="code" href="group__streams.html#ga3371300a9eea0177e792b08bb5b3bf3d">using_bstream</a>(s){</div><div class="line">   <a class="code" href="group__buffers.html#structuv__buf__t">uv_buf_t</a> buf = <a class="code" href="group__streams.html#ga353b56dd825e99a056c7cd6ebfd1635a">async_read_buf_all</a>(s);</div><div class="line">   {<a class="code" href="group__buffers.html#gac1eb74560e4589e704bebc105d6343d3">using_buf</a>(&amp;buf){</div><div class="line">      printf(<span class="stringliteral">&quot;received: %s\n&quot;</span>, buf.<a class="code" href="group__buffers.html#a728c18d77668f4691201c4937133d7f0">base</a>);</div><div class="line">   }}</div><div class="line">}}</div></div><!-- fragment --> 
</div>
</div>
<a id="gaf8015d9228ada99910bc414d748536e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8015d9228ada99910bc414d748536e8">&#9670;&nbsp;</a></span>using_stream</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define using_stream</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s</td><td>)</td>
          <td>&#160;&#160;&#160;defer_exit(<a class="el" href="group__streams.html#ga530b49b85b811a2377209a55b2e670cb">async_shutdown</a>(s),&amp;<a class="el" href="group__streams.html#ga29902a3b1e06b6d1b87e11b12bfbb11a">nodec_stream_freev</a>,lh_value_ptr(s))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use a stream in a scope, freeing the stream when exiting. </p>
<p>This safely uses the stream in a scope and frees the stream afterwards (even if an exception is thrown). Uses async_shutdown(stream) too if no exception was thrown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the <a class="el" href="group__streams.html#gaee920c8bd173ce7bf3b57f42cbcf3f5f" title="Basic unbuffered streams. ">nodec_stream_t</a> to free after use.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example</b> </p><div class="fragment"><div class="line"><a class="code" href="group__streams.html#gaee920c8bd173ce7bf3b57f42cbcf3f5f">nodec_stream_t</a> s = ...</div><div class="line">{<a class="code" href="group__streams.html#gaf8015d9228ada99910bc414d748536e8">using_stream</a>(s){</div><div class="line">   <a class="code" href="group__streams.html#ga333329e70821cc682fdeaa333f210260">async_write</a>(s, <span class="stringliteral">&quot;hello&quot;</span>);</div><div class="line">}}</div></div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gadaf4d5e2ac9a12cc14da8fa006d85916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadaf4d5e2ac9a12cc14da8fa006d85916">&#9670;&nbsp;</a></span>nodec_bstream_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct _nodec_bstream_t <a class="el" href="group__streams.html#gadaf4d5e2ac9a12cc14da8fa006d85916">nodec_bstream_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of buffered streams. </p>
<p>Derives from a basic <a class="el" href="group__streams.html#gaee920c8bd173ce7bf3b57f42cbcf3f5f" title="Basic unbuffered streams. ">nodec_stream_t</a> and can be cast to it using <a class="el" href="group__streams.html#ga5086fb89c05a1dc0ecf923af3e953403" title="Safely cast a buffered stream to a basic stream. ">as_stream()</a>. Buffered streams have added functionality, like being able to read a stream up to a certain pattern is encountered, or reading the full stream as a single buffer. </p>

</div>
</div>
<a id="gaa1b461b8603be0c65dbf1e6037b01668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1b461b8603be0c65dbf1e6037b01668">&#9670;&nbsp;</a></span>uv_stream_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct _uv_stream_t <a class="el" href="group__streams.html#gaa1b461b8603be0c65dbf1e6037b01668">uv_stream_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <code>libuv</code> stream. </p>
<p>Try not to use these directly but wrap it into a buffered stream, See <a class="el" href="group__streams.html#ga3402e9960bf043d2d361225e18483645" title="Low level: Create a buffered stream from an internal uv_stream_t. ">nodec_bstream_alloc()</a> and <a class="el" href="group__streams.html#gac952f2f3a280250a382a36419f7b16da" title="Low level: Create a buffered stream from an internal uv_stream_t for reading. ">nodec_bstream_alloc_read()</a>. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga8406e8a53fce782cb90557358c6290c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8406e8a53fce782cb90557358c6290c3">&#9670;&nbsp;</a></span>async_read_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* async_read_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__streams.html#gadaf4d5e2ac9a12cc14da8fa006d85916">nodec_bstream_t</a> *&#160;</td>
          <td class="paramname"><em>bstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>read_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the entire stream as a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bstream</td><td>the stream to read from. </td></tr>
    <tr><td class="paramname">read_max</td><td>maximum number of bytes to read. Use 0 (or <code>SIZE_MAX</code>) for unlimited. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the data read in a callee owned string (see using_str()). </dd></dl>

</div>
</div>
<a id="ga3c8beb53a775b37e696fdf5e8e31d6d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c8beb53a775b37e696fdf5e8e31d6d6">&#9670;&nbsp;</a></span>async_read_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__buffers.html#structuv__buf__t">uv_buf_t</a> async_read_buf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__streams.html#gaee920c8bd173ce7bf3b57f42cbcf3f5f">nodec_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously read a buffer from a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>stream to read from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__buffers.html#structuv__buf__t" title="A libuv buffer. ">uv_buf_t</a> a buffer with the data. This buffer is becomes the callee's responsibility (see <a class="el" href="group__buffers.html#gac1eb74560e4589e704bebc105d6343d3" title="Use a buffer in a scope, freeing automatically when exiting. ">using_buf()</a>) and is passed without copying from the lower level read routines. </dd></dl>

</div>
</div>
<a id="ga353b56dd825e99a056c7cd6ebfd1635a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga353b56dd825e99a056c7cd6ebfd1635a">&#9670;&nbsp;</a></span>async_read_buf_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__buffers.html#structuv__buf__t">uv_buf_t</a> async_read_buf_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__streams.html#gadaf4d5e2ac9a12cc14da8fa006d85916">nodec_bstream_t</a> *&#160;</td>
          <td class="paramname"><em>bstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>read_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the entire stream as a single buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bstream</td><td>the stream to read from. </td></tr>
    <tr><td class="paramname">read_max</td><td>maximum number of bytes to read. Use 0 (or <code>SIZE_MAX</code>) for unlimited. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the data read in a callee owned buffer (see <a class="el" href="group__buffers.html#gac1eb74560e4589e704bebc105d6343d3" title="Use a buffer in a scope, freeing automatically when exiting. ">using_buf()</a>). </dd></dl>

</div>
</div>
<a id="gabdf6ced2f262d5a4285465e347af1d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdf6ced2f262d5a4285465e347af1d79">&#9670;&nbsp;</a></span>async_read_buf_including()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__buffers.html#structuv__buf__t">uv_buf_t</a> async_read_buf_including </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__streams.html#gadaf4d5e2ac9a12cc14da8fa006d85916">nodec_bstream_t</a> *&#160;</td>
          <td class="paramname"><em>bstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>toread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pat_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>read_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a stream until some pattern is encountered. </p>
<p>The returned buffer will contain <code>pat</code> unless the end-of-stream was encountered or <code>read_max</code> bytes were read. The return buffer may contain more data following the the pattern <code>pat</code>. This is more efficient than async_read_buf_upto which may involve some memory copying to split buffers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">bstream</td><td>the stream to read from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">toread</td><td>the number of bytes just including the pattern <code>pat</code>. 0 on failure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pat</td><td>the pattern to scan for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pat_len</td><td>the length of the patter. For efficiency reasons, this can be at most 8 (bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">read_max</td><td>stop reading after <code>read_max</code> bytes have been seen. Depending on the internal buffering, the returned buffer might still contain more bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>buffer with the read bytes where <code>buf.len &gt;= *toread</code>. Returns a null buffer (see <a class="el" href="group__buffers.html#gace6138cbc07d9e625f7fe5dd23f14a53" title="Is this a null buffer?. ">nodec_buf_is_null()</a>) if an end-of-stream is encountered. </dd></dl>

</div>
</div>
<a id="ga944deab13d009fe3b6b94a8c7c4943b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga944deab13d009fe3b6b94a8c7c4943b9">&#9670;&nbsp;</a></span>async_read_buf_upto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__buffers.html#structuv__buf__t">uv_buf_t</a> async_read_buf_upto </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__streams.html#gadaf4d5e2ac9a12cc14da8fa006d85916">nodec_bstream_t</a> *&#160;</td>
          <td class="paramname"><em>bstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pat_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>read_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a stream until some pattern is encountered. </p>
<p>The returned buffer will contain <code>pat</code> at its end unless the end-of-stream was encountered or <code>read_max</code> bytes were read. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">bstream</td><td>the stream to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pat</td><td>the pattern to scan for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pat_len</td><td>the length of the patter. For efficiency reasons, this can be at most 8 (bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">read_max</td><td>stop reading after <code>read_max</code> bytes have been seen. Depending on the internal buffering, the returned buffer might still contain more bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>buffer with the read bytes. Returns a null buffer (see <a class="el" href="group__buffers.html#gace6138cbc07d9e625f7fe5dd23f14a53" title="Is this a null buffer?. ">nodec_buf_is_null()</a>) if an end-of-stream is encountered. </dd></dl>

</div>
</div>
<a id="ga756ccec235ed35716f4c725a948a7943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga756ccec235ed35716f4c725a948a7943">&#9670;&nbsp;</a></span>async_read_bufx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__buffers.html#structuv__buf__t">uv_buf_t</a> async_read_bufx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__streams.html#gaee920c8bd173ce7bf3b57f42cbcf3f5f">nodec_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>buf_owned</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously read a buffer from a stream. </p>
<p>This is the most efficient form of reading since it can even read by providing <em>unowned</em> view buffers but it is also most complex as returned unowned buffers are only valid until the next read call. See <a class="el" href="group__streams.html#ga3c8beb53a775b37e696fdf5e8e31d6d6" title="Asynchronously read a buffer from a stream. ">async_read_buf()</a> for more robust reading that always returns callee owned buffers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">stream</td><td>stream to read from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf_owned</td><td>this is set to <code>true</code> if the returned buffer is <em>owned</em>, i.e. should be freed by the callee. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a buffer with the data. This buffer is becomes the callee's responsibility if <code>buf_owned</code> is true; otherwise the buffer should <em>not</em> be freed by the callee. See <a class="el" href="group__buffers.html#ga3e5bc4c460db62160c8642b8e1d65c1b" title="Use a potentially owned buffer in a scope. ">using_buf_owned()</a> to do this automatically. Moreover, if a buffer is returned with <code>*buf_owned</code> false, the buffer only stays valid until the next read from that stream.</dd></dl>
<p><b>Example</b> </p><div class="fragment"><div class="line"><a class="code" href="group__streams.html#gaee920c8bd173ce7bf3b57f42cbcf3f5f">nodec_stream_t</a> stream = <a class="code" href="group__http__req__resp.html#gac25ef2db063b5b4f33e4fb3042137dab">http_req_body</a>();</div><div class="line">{<a class="code" href="group__streams.html#gaf8015d9228ada99910bc414d748536e8">using_stream</a>(stream){</div><div class="line">   <a class="code" href="group__buffers.html#structuv__buf__t">uv_buf_t</a> buf;</div><div class="line">   <span class="keywordtype">bool</span> owned;</div><div class="line">   <span class="keywordflow">while</span>( (buf = <a class="code" href="group__streams.html#ga756ccec235ed35716f4c725a948a7943">async_read_bufx</a>(stream,&amp;owned), !<a class="code" href="group__buffers.html#gace6138cbc07d9e625f7fe5dd23f14a53">nodec_buf_is_null</a>(buf)) ) {</div><div class="line">     {<a class="code" href="group__buffers.html#ga3e5bc4c460db62160c8642b8e1d65c1b">using_buf_owned</a>(owned,buf){</div><div class="line">        printf(<span class="stringliteral">&quot;data read: %s\n&quot;</span>, buf.<a class="code" href="group__buffers.html#a728c18d77668f4691201c4937133d7f0">base</a>);</div><div class="line">     }}</div><div class="line">   }</div><div class="line">}}</div></div><!-- fragment --> 
</div>
</div>
<a id="gae0d28422e33ff8ba269b4982ec7160aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0d28422e33ff8ba269b4982ec7160aa">&#9670;&nbsp;</a></span>async_read_into()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t async_read_into </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__streams.html#gadaf4d5e2ac9a12cc14da8fa006d85916">nodec_bstream_t</a> *&#160;</td>
          <td class="paramname"><em>bstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__buffers.html#structuv__buf__t">uv_buf_t</a>&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a stream into a pre-allocated buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bstream</td><td>the stream to read from. </td></tr>
    <tr><td class="paramname">buf</td><td>the buffer to read into; reads up to either the end of the stream or up to the <code>buf.len</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes read. </dd></dl>

</div>
</div>
<a id="ga530b49b85b811a2377209a55b2e670cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga530b49b85b811a2377209a55b2e670cb">&#9670;&nbsp;</a></span>async_shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void async_shutdown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__streams.html#gaee920c8bd173ce7bf3b57f42cbcf3f5f">nodec_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shutdown a stream. </p>
<p>This closes the stream gracefully for writes (<a class="el" href="group__streams.html#ga7a87a30d292c709502440b0d95b9cb0b" title="Free a basic stream. ">nodec_stream_free()</a> does this too but closes the stream abruptly). Usually this is not used directly but instead <a class="el" href="group__streams.html#gaf8015d9228ada99910bc414d748536e8" title="Use a stream in a scope, freeing the stream when exiting. ">using_stream()</a> is used. </p>

</div>
</div>
<a id="ga333329e70821cc682fdeaa333f210260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga333329e70821cc682fdeaa333f210260">&#9670;&nbsp;</a></span>async_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void async_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__streams.html#gaee920c8bd173ce7bf3b57f42cbcf3f5f">nodec_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a string to a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>stream to write to. </td></tr>
    <tr><td class="paramname">s</td><td>the string to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga254f878556059c35448ad927ab982f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga254f878556059c35448ad927ab982f36">&#9670;&nbsp;</a></span>async_write_bufs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void async_write_bufs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__streams.html#gaee920c8bd173ce7bf3b57f42cbcf3f5f">nodec_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__buffers.html#structuv__buf__t">uv_buf_t</a>&#160;</td>
          <td class="paramname"><em>bufs</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write an array of buffers to a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>the stream to write to. </td></tr>
    <tr><td class="paramname">bufs</td><td>the array of buffers to write. </td></tr>
    <tr><td class="paramname">count</td><td>the number of buffers in the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3402e9960bf043d2d361225e18483645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3402e9960bf043d2d361225e18483645">&#9670;&nbsp;</a></span>nodec_bstream_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__streams.html#gadaf4d5e2ac9a12cc14da8fa006d85916">nodec_bstream_t</a>* nodec_bstream_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__streams.html#gaa1b461b8603be0c65dbf1e6037b01668">uv_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Low level: Create a buffered stream from an internal <code>uv_stream_t</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>the underlying <code>uv_stream_t</code>. Freed when the <a class="el" href="group__streams.html#gadaf4d5e2ac9a12cc14da8fa006d85916" title="The type of buffered streams. ">nodec_bstream_t</a> is freed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a buffered stream. </dd></dl>

</div>
</div>
<a id="gac952f2f3a280250a382a36419f7b16da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac952f2f3a280250a382a36419f7b16da">&#9670;&nbsp;</a></span>nodec_bstream_alloc_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__streams.html#gadaf4d5e2ac9a12cc14da8fa006d85916">nodec_bstream_t</a>* nodec_bstream_alloc_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__streams.html#gaa1b461b8603be0c65dbf1e6037b01668">uv_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Low level: Create a buffered stream from an internal <code>uv_stream_t</code> for reading. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>the underlying <code>uv_stream_t</code>. Freed when the <a class="el" href="group__streams.html#gadaf4d5e2ac9a12cc14da8fa006d85916" title="The type of buffered streams. ">nodec_bstream_t</a> is freed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a buffered stream. </dd></dl>

</div>
</div>
<a id="ga46bab5d4f8f6d45e6eb3587b796683a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46bab5d4f8f6d45e6eb3587b796683a2">&#9670;&nbsp;</a></span>nodec_bstream_alloc_read_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__streams.html#gadaf4d5e2ac9a12cc14da8fa006d85916">nodec_bstream_t</a>* nodec_bstream_alloc_read_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__streams.html#gaa1b461b8603be0c65dbf1e6037b01668">uv_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alloc_init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alloc_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Low level: Create a buffered stream from an internal <code>uv_stream_t</code> for reading. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>the underlying <code>uv_stream_t</code>. Freed when the <a class="el" href="group__streams.html#gadaf4d5e2ac9a12cc14da8fa006d85916" title="The type of buffered streams. ">nodec_bstream_t</a> is freed. </td></tr>
    <tr><td class="paramname">alloc_init</td><td>the initial allocation size for read buffers. Use 0 for default (8k). Doubles on further data until <code>alloc_max</code>. </td></tr>
    <tr><td class="paramname">alloc_max</td><td>the maximal allocation size for read buffers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a buffered stream. </dd></dl>

</div>
</div>
<a id="gaa2323dea0f12493ae97032fe7e6dcd55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2323dea0f12493ae97032fe7e6dcd55">&#9670;&nbsp;</a></span>nodec_pushback_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nodec_pushback_buf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__streams.html#gadaf4d5e2ac9a12cc14da8fa006d85916">nodec_bstream_t</a> *&#160;</td>
          <td class="paramname"><em>bstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__buffers.html#structuv__buf__t">uv_buf_t</a>&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push back a buffer onto a read stream. </p>
<p>The data pushed back will be read on the next read call. </p>

</div>
</div>
<a id="ga7a87a30d292c709502440b0d95b9cb0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a87a30d292c709502440b0d95b9cb0b">&#9670;&nbsp;</a></span>nodec_stream_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nodec_stream_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__streams.html#gaee920c8bd173ce7bf3b57f42cbcf3f5f">nodec_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a basic stream. </p>
<p>Usually this is not used directly but instead <a class="el" href="group__streams.html#gaf8015d9228ada99910bc414d748536e8" title="Use a stream in a scope, freeing the stream when exiting. ">using_stream()</a> is used. </p>

</div>
</div>
<a id="ga29902a3b1e06b6d1b87e11b12bfbb11a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29902a3b1e06b6d1b87e11b12bfbb11a">&#9670;&nbsp;</a></span>nodec_stream_freev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nodec_stream_freev </td>
          <td>(</td>
          <td class="paramtype">lh_value&#160;</td>
          <td class="paramname"><em>streamv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a basic stream as an <code>lh_value</code>. </p>
<p>Usually this is not used directly but instead <a class="el" href="group__streams.html#gaf8015d9228ada99910bc414d748536e8" title="Use a stream in a scope, freeing the stream when exiting. ">using_stream()</a> is used. </p>

</div>
</div>
<a id="ga8a923b29a649bffb076c7d7c10d14459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a923b29a649bffb076c7d7c10d14459">&#9670;&nbsp;</a></span>nodec_zstream_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__streams.html#gadaf4d5e2ac9a12cc14da8fa006d85916">nodec_bstream_t</a>* nodec_zstream_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__streams.html#gaee920c8bd173ce7bf3b57f42cbcf3f5f">nodec_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a stream over another stream that is gzip'd. </p>
<p>Reading unzips, while writing zips again. Uses a default compression level of 6 and gzip format (instead of deflate). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>the gzipped stream &ndash; after allocation the returned stream owns this stream and takes care of shutdown and free. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new buffered stream that automatically (de)compresses. </dd></dl>

</div>
</div>
<a id="ga2e497767efc4c4d27982e5c9771dfb2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e497767efc4c4d27982e5c9771dfb2c">&#9670;&nbsp;</a></span>nodec_zstream_alloc_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__streams.html#gadaf4d5e2ac9a12cc14da8fa006d85916">nodec_bstream_t</a>* nodec_zstream_alloc_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__streams.html#gaee920c8bd173ce7bf3b57f42cbcf3f5f">nodec_stream_t</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compress_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>gzip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a stream over another stream that is gzip'd. </p>
<p>Reading unzips automatically, while writing zips again. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>the gzipped stream &ndash; after allocation the returned stream owns this stream and takes care of shutdown and free. </td></tr>
    <tr><td class="paramname">compress_level</td><td>the compression level to use between 1 and 9 (6 by default, which is a good balance between speed and compression ratio). </td></tr>
    <tr><td class="paramname">gzip</td><td>if <code>true</code> uses the gzip format for compression while reading both deflate and gzip streams. If false, uses deflate for both compression and decompression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new buffered stream that automatically (de)compresses. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
